{"version":3,"sources":["../src/zklock.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,SAAS,MAAM,uBAAuB,CAAA;AAElD,OAAO,EAAE,KAAK,MAAM,EAAE,MAAM,SAAS,CAAA;AAErC,MAAM,WAAW,sBAAsB;IACrC,MAAM,EAAE,MAAM,CAAA;CACf;AACD,qBAAa,eAAe;IAC1B,SAAgB,QAAQ,EAAE,SAAS,CAAC,MAAM,CAAA;IAC1C,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAQ;IACxC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAQ;IACjC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAc;IACpC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAQ;gBAE7B,eAAe,EAAE,MAAM,EACvB,QAAQ,EAAE,MAAM,EAChB,OAAO,CAAC,EAAE,sBAAsB;IASrB,IAAI,IAAK,OAAO,CAAC,IAAI,CAAC;IAQtB,WAAW,CAAE,QAAQ,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,KAAK,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IAqBpE,WAAW,CAChB,QAAQ,EAAE,MAAM,EAChB,QAAQ,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,KAAK,IAAI,GAChC,IAAI;IAeA,KAAK,IAAK,IAAI;IAKd,EAAE,CAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,IAAI,GAAG,IAAI;IAI5D,IAAI,CAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,IAAI,GAAG,IAAI;CAGtE","file":"zklock.d.ts","sourcesContent":["/* eslint-disable @typescript-eslint/explicit-member-accessibility */\r\nimport * as zookeeper from 'node-zookeeper-client'\r\nimport { logger } from './logger'\r\nimport { type Logger } from 'winston'\r\n\r\nexport interface DistributedLockOptions {\r\n  logger: Logger\r\n}\r\nexport class DistributedLock {\r\n  public readonly zkClient: zookeeper.Client\r\n  private readonly zkConnectString: string\r\n  private readonly lockPath: string\r\n  private readonly ready: Promise<any>\r\n  private readonly logger: Logger\r\n  constructor (\r\n    zkConnectString: string,\r\n    lockPath: string,\r\n    options?: DistributedLockOptions\r\n  ) {\r\n    this.zkConnectString = zkConnectString\r\n    this.lockPath = lockPath\r\n    this.zkClient = zookeeper.createClient(this.zkConnectString)\r\n    this.logger = (options != null) && options.logger ? options.logger : logger\r\n    this.ready = this.init()\r\n  }\r\n\r\n  public async init (): Promise<void> {\r\n    this.zkClient.once('connected', () => {\r\n      this.logger.info('Distributed Lock initialised')\r\n    })\r\n\r\n    await this.zkClient.connect()\r\n  }\n\r\n  public async acquireLock (callback: (error?: Error) => void): Promise<void> {\r\n    await this.ready\r\n    this.zkClient.create(\r\n      this.lockPath,\r\n      null as any,\r\n      zookeeper.CreateMode.EPHEMERAL,\r\n      (error: any, lockPath: any) => {\r\n        if (error) {\r\n          this.logger.error(\r\n            `Error in acquiring lock on path ${lockPath} error: ${error.message}`\r\n          )\r\n          callback(error as Error | undefined)\r\n          return\r\n        }\r\n        this.logger.info(`Lock acquiring successfully on path ${lockPath}`)\r\n\r\n        callback()\r\n      }\r\n    )\r\n  }\r\n\r\n  public releaseLock (\r\n    lockPath: string,\r\n    callback: (error?: Error) => void\r\n  ): void {\r\n    this.zkClient.remove(lockPath, (error: any) => {\r\n      if (error) {\r\n        this.logger.error(\r\n          `Error in releasing lock on path ${lockPath}  error: ${error.message}`\r\n        )\r\n\r\n        callback(error as Error | undefined)\r\n        return\r\n      }\r\n      this.logger.info(`Lock released successfully on path ${lockPath}`)\r\n      callback()\r\n    })\r\n  }\r\n\r\n  public close (): void {\r\n    this.logger.info('Distributed Lock closing connextion')\r\n    this.zkClient.close()\r\n  }\n\r\n  public on (event: string, listener: (...args: any[]) => void): void {\r\n    this.zkClient.on(event, listener)\r\n  }\r\n\r\n  public once (event: string, listener: (...args: any[]) => void): void {\r\n    this.zkClient.once(event, listener)\r\n  }\r\n}\r\n"]}